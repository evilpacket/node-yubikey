/*
 * Yubikey Module for NodeJS
 *
 * Validate Yubikeys via Yubico Web Services API.
 *
 * Yubico API Ids and Keys can be requested from https://upgrade.yubico.com/getapikey/
 *
 * Example usage:
 *
 *       var yubikey = require(./yubikey.js);
 *       yubikey.apiId = 1234;
 *       yubikey.apiKey = 'asdfasdf';
 *       
 *       yubikey.verify('cccccccedjcrkjftthlbkgnhnugvbhidjleuddbghhnl', function(isValid) {
 *             console.log(isValid ? 'Yubikey is valid' : 'Yubikey is not valid');
 *       })
 *
 * Copyright 2010 Brendan Young <brendan@brandtheory.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 */


var http = require('http'),
	crypto = require('crypto'),
	querystring = require('querystring');

var verifyServers = [
	'api.yubico.com',
	'api2.yubico.com', 
	'api3.yubico.com', 
	'api4.yubico.com',
	'api5.yubico.com'
];

var currentServer = 0;

var apiId = exports.apiId = undefined;
var apiKey = exports.apiKey = undefined;
var debug = exports.debug = false;

/**
 * Verifies Yubikey One-Time-Password with verification servers
 * and sends response in callback
 *
 * @param {String} value The OTP generated by a Yubikey
 * @param {Function} callback Callback function with response passed as an argument example. callback(boolean, 'Response message')
 * @param {Object} config Optionally pass in API ID and signature key example. {apiId: 1234, apiKey: 'abcdefg123456'};
 */
var verify = exports.verify = function(otp, callback, config) {
	
	apiId = (config && config.apiId) || exports.apiId;
	apiKey = (config && config.apiKey) || exports.apiKey;
	
	if(typeof otp === 'undefined') {
		throw callback(false, 'OTP is missing.');
	} else if(otp.length != 44 || !isModHex(otp)) {
		throw callback(false, 'Invalid OTP.');
	}
	
	var vars = {};

	vars.nonce = crypto.createHash('md5').update(Math.round(Math.random() * 1e50) + (new Date*1)).digest('hex');
	vars.otp = otp;

	if(apiId && apiKey) {
		vars['id'] = apiId;
		vars.h = generateSignature(vars);
	}
	
	sendRequest(verifyServers[currentServer], vars, callback);
}

function sendRequest(host, vars, callback) {
	
	var query = '/wsapi/2.0/verify?' + querystring.stringify(vars);
	
	var yubikeyVerify = http.createClient(443, host, true);
	var request = yubikeyVerify.request('GET', query, {'host': host});
	request.end();
	
	request.on('response', function (response) {
		if(response.statusCode === 200) {
			response.setEncoding('utf8');
			response.on('data', function (data) {
				responseVars = querystring.parse(data.replace(/\r\n/g, '&'));
				verifyResponse(responseVars, vars, callback);
		  });
		} else {
			nextRequest(vars, callback);
		}
	});
	
	request.on('error', function (err) {
		nextRequest(vars, callback, err);
	});
	yubikeyVerify.on('error', function (err) {
		nextRequest(vars, callback, err);
	});
}

function nextRequest(vars, callback, err) {
	
	if(debug || exports.debug) console.log('Request to ' + verifyServers[currentServer] + ' failed. ' + err);
	
	currentServer++;
	if(currentServer <  verifyServers.length) {
		sendRequest(verifyServers[currentServer], vars, callback);
	} else {
		throw new Error('Unable to reach Yubikey verification servers.');
	}
	
}

var errors = {
	'REPLAYED_OTP': 'The OTP has already been seen by the service.',
	'REPLAYED_REQUEST': 'Server has seen the OTP/Nonce combination before.',
	'BAD_SIGNATURE': 'The request signature failed verification.',
	'MISSING_PARAMETER': 'The request lacks a parameter.',
	'NO_SUCH_CLIENT': 'The request id does not exist.',
	'OPERATION_NOT_ALLOWED': 'The request id is not allowed to verify OTPs.',
	'BACKEND_ERROR': 'Unexpected error in Yubico server.',
	'NOT_ENOUGH_ANSWERS': 'Server could not get requested number of syncs during before timeout.'
};

function verifyResponse(responseVars, requestVars, callback) {

	if(responseVars.otp != requestVars.otp) {
		throw new Error('Response OTP does not match request OTP.');
	} else if(responseVars.nonce != requestVars.nonce) {
		throw new Error('Response nonce does not match request nonce.');
	} else if(responseVars.h) {
		var signature = responseVars.h.replace(/ /g, '+'); // Restore escaped + characters if needed
		delete responseVars.h;
		
		if(signature !== generateSignature(responseVars)) {
			throw new Error('Response signature is invalid');
		}
	}
	
	var status = responseVars['status'];
	
	if(status === 'OK') {
		callback(true, 'OTP has successfully been verified.');
	} else if(status === 'BAD_OTP' || status === 'REPLAYED_OTP' || status === 'REPLAYED_REQUEST') {
		callback(false, errors[status]);
	} else if(errors[status]) {
		throw new Error(errors[status]);
	} else {
		throw new Error('Invalid response from verification server.');
	}
	
}

function isModHex(otp) {
	return otp.search(/[^cbdefghijklnrtuv]/) ? true : false;
}

function generateSignature(vars) {
	
	if(!apiKey) return;
	
	var hmac = crypto.createHmac('sha1', new Buffer(apiKey, 'base64').toString('binary'));
	return hmac.update(orderedStringify(vars)).digest('base64');
}

function orderedStringify(vars) {
	
	var query = [];

	// Yubikey requires query strings are in alphabetical order for the signature
	Object.keys(vars).sort().forEach(function(key){
		query.push(key + '=' + vars[key]);
	})
	
	return query.join('&');
}
