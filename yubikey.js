/*
 * Yubikey Web Service Client Module for NodeJS
 *
 * Validate Yubikeys via Yubico Web Services API. (http://yubico.com)
 *
 * Yubikey tokens can be purchased from https://store.yubico.com/
 * Yubico API id and signature key can be requested from https://upgrade.yubico.com/getapikey/
 *
 * Example usage:
 *
 *       var yubikey = require(./yubikey.js);
 *
 *       // Replace with your Yubico API Id and Key
 *       yubikey.apiId = 1234; // Required
 *       yubikey.apiKey = 'asdfasdf'; // Optional, will add HMAC-SHA-1 signature in requests and verify signature in response when set
 *
 *       var otp = 'ccccccceabcrkjftthlbkgnhnugvbhidjleuddbghhnl'; // OTP generated by Yubikey
 *
 *       yubikey.verify(otp, function(isValid) {
 *             console.log(isValid ? 'Yubikey is valid' : 'Yubikey is not valid');
 *       })
 *
 *
 * More Info:
 *
 *     http://yubico.com
 *     http://code.google.com/p/yubikey-val-server-php/wiki/ValidationProtocolV20
 *
 * Copyright 2010 Brendan Young <brendan@brandtheory.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 */


var https = require('https'),
	crypto = require('crypto'),
	querystring = require('querystring');

var verifyServers = [
	'api.yubico.com',
	'api2.yubico.com', 
	'api3.yubico.com', 
	'api4.yubico.com',
	'api5.yubico.com'
];

var currentServer = 0;

var apiId = exports.apiId = undefined;
var apiKey = exports.apiKey = undefined;
var debug = exports.debug = false;

/**
 * Verifies Yubikey One-Time-Password with verification servers
 * and sends response in callback
 *
 * @param {String} value The OTP generated by a Yubikey
 * @param {Function} callback Callback function with response passed as an argument example. callback(boolean, 'Response message')
 * @param {Object} config Optionally pass in API ID and signature key example. {apiId: 1234, apiKey: 'abcdefg123456'};
 */
var verify = exports.verify = function(otp, callback, config) {
	
	apiId = (config && config.apiId) || exports.apiId;
	apiKey = (config && config.apiKey) || exports.apiKey;
	
	if(typeof otp === 'undefined') {
		throw callback(false, 'OTP is missing.');
	} else if(otp.length != 44 || !isModHex(otp)) {
		throw callback(false, 'Invalid OTP.');
	} else if(!apiId) {
		throw callback(false, 'Yubico API id missing.');
	}
	
	var vars = {};

	vars.nonce = crypto.createHash('md5').update((Math.round(Math.random() * 1e50) + (new Date*1)).toString()).digest('hex');
	vars.otp = otp;
	vars['id'] = apiId;
	
	if(apiKey) {
		vars.h = generateSignature(vars);
	}
	
	sendRequest(verifyServers[currentServer], vars, callback);
}

function sendRequest(host, vars, callback) {
	
	var query = '/wsapi/2.0/verify?' + querystring.stringify(vars);
	
	if(debug || exports.debug) console.log('Request: ' + host + query);
	
     var request = https.get({host: host, path: query}, function(response) {
         if(response.statusCode === 200) {
            response.setEncoding('utf8');
            response.on('data', function (data) {
                if(debug || exports.debug) console.log('Response: ' + data);
                responseVars = querystring.parse(data.replace(/\r\n/g, '&'));
                verifyResponse(responseVars, vars, callback);
         });
         } else {
            nextRequest(vars, callback);
         }
     }).on('error', function(err) {
         nextRequest(vars, callback, err);
     });
}

function nextRequest(vars, callback, err) {
	
	if(debug || exports.debug) console.log('Request to ' + verifyServers[currentServer] + ' failed. ' + err);
	
	currentServer++;
	if(currentServer <  verifyServers.length) {
		sendRequest(verifyServers[currentServer], vars, callback);
	} else {
		throw new Error('Unable to reach Yubikey verification servers.');
	}
}

var errors = {
	'REPLAYED_OTP': 'The OTP has already been used.',
	'REPLAYED_REQUEST': 'Server has seen the OTP/Nonce combination before.',
	'BAD_SIGNATURE': 'The request signature failed verification.',
	'MISSING_PARAMETER': 'The request lacks a parameter.',
	'NO_SUCH_CLIENT': 'The request id does not exist.',
	'OPERATION_NOT_ALLOWED': 'The request id is not allowed to verify OTPs.',
	'BACKEND_ERROR': 'Unexpected error in Yubico server.',
	'NOT_ENOUGH_ANSWERS': 'Server could not get requested number of syncs during before timeout.'
};

function verifyResponse(responseVars, requestVars, callback) {

	if(responseVars.otp != requestVars.otp) {
		callback(false, 'Response and request OTP do not match.');
	} else if(responseVars.nonce != requestVars.nonce) {
		callback(false, 'Response and request nonce do not match.');
	} else if(apiKey) {
		if(!responseVars.h) {
			callback(false, 'Response signature is missing.');
		}
		
		var signature = responseVars.h.replace(/ /g, '+'); // Restore escaped + characters if needed
		delete responseVars.h;
		
		if(signature !== generateSignature(responseVars)) {
			callback(false, 'Response signature is invalid.');
		}
	}
	
	var status = responseVars['status'];
	
	if(status === 'OK') {
		callback(true, 'OTP has successfully been verified.');
	} else if(status === 'BAD_OTP' || status === 'REPLAYED_OTP' || status === 'REPLAYED_REQUEST') {
		callback(false, errors[status]);
	} else if(errors[status]) {
		throw new Error(errors[status]);
	} else {
		callback(false, 'Invalid response from verification server.');
	}
	
}

function isModHex(otp) {
	return otp.search(/[^cbdefghijklnrtuv]/) ? true : false;
}

function generateSignature(vars) {
	
	if(!apiKey) return;
	
	var hmac = crypto.createHmac('sha1', new Buffer(apiKey, 'base64').toString('binary'));
	return hmac.update(orderedStringify(vars)).digest('base64');
}

function orderedStringify(vars) {
	
	var query = [];

	// Yubikey requires query strings are in alphabetical order for the signature
	Object.keys(vars).sort().forEach(function(key){
        if(key != "") {
		    query.push(key + '=' + vars[key]);
        }
	})
	
	return query.join('&');
}
